
#[cfg(test)]
mod tests;

mod utils;


/// If we list all the natural numbers below 10 that are multiples of 3 or 5, we
/// get 3, 5, 6 and 9. The sum of these multiples is 23.
///
/// Find the sum of all the multiples of 3 or 5 below 1000.
#[allow(dead_code)]
fn problem_001() -> i32 {
    let mut acc: i32 = 0;

    for i in 0..1000 {
        if i % 3 == 0 || i % 5 == 0 {
            acc += i;
        }
    }

    acc
}


/// Each new term in the Fibonacci sequence is generated by adding the previous
/// two terms. By starting with 1 and 2, the first 10 terms will be:
///
/// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
///
/// By considering the terms in the Fibonacci sequence whose values do not
/// exceed four million, find the sum of the even-valued terms.
#[allow(dead_code)]
fn problem_002() -> i64 {
    fn fib(acc: i64, a: i64, b: i64) -> i64 {
        if a < 4000000 {
            if a % 2 == 0 {
                fib(acc + a, b, a + b)
            } else {
                fib(acc, b, a + b)
            }
        } else {
            acc
        }
    };

    fib(0, 1, 2)
}

/// The prime factors of 13195 are 5, 7, 13 and 29.
///
/// What is the largest prime factor of the number 600851475143 ?
#[allow(dead_code)]
fn problem_003() -> i64 {
    let target = 600851475143;
    let mut f = (target as f64).sqrt() as i64 + 1;

    while f > 0 {
        if target % f == 0 && utils::is_prime(f) {
            return f;
        }
        f -= 1;
    }

    0
}


/// A palindromic number reads the same both ways. The largest palindrome made 
/// from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
///
/// Find the largest palindrome made from the product of two 3-digit numbers.
#[allow(dead_code)]
fn problem_004() -> i64{
    let mut max = 0;
    for i in (100..999).rev() {
        for j in (100..999).rev() {
            let p = i * j;
            if max < p && utils::is_palindrome(p) {
                max = p;
            }
        }
    }

    max
}


fn main() {}
